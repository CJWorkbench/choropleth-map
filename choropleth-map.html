<html>
<!-- Much of the code here is written based on this tutorial: https://leafletjs.com/examples/choropleth/ -->
<head>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
</head>
<body>
    <div id='map-div' style='height:315px'></div>
</body>
<style>
#map-div {
    top: 52px;
}
.info {
    padding: 6px 8px;
    font: 14px/16px Arial, Helvetica, sans-serif;
    background: white;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 3px;
}
.info h4 {
    margin: 0 0 5px;
    color: #777;
}
.legend {
    line-height: 18px;
    color: #555;
}
.legend i {
    width: 18px;
    height: 18px;
    float: left;
    margin-right: 8px;
    opacity: 0.7;
}
</style>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js" integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw==" crossorigin=""></script>
<script>
/*
    Color gradient generation function lifted from https://stackoverflow.com/a/32257791
*/
function hex(c) {
    var s = "0123456789abcdef";
    var i = parseInt (c);
    if (i == 0 || isNaN (c))
    return "00";
    i = Math.round (Math.min (Math.max (0, i), 255));
    return s.charAt ((i - i % 16) / 16) + s.charAt (i % 16);
}

/* Convert an RGB triplet to a hex string */
function convertToHex(rgb) {
    return hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
}

/* Remove '#' in color hex string */
function trim(s) {
    return (s.charAt(0) == '#') ? s.substring(1, 7) : s
}

/* Convert a hex string to an RGB triplet */
function convertToRGB(hex) {
    var color = [];
    color[0] = parseInt ((trim(hex)).substring (0, 2), 16);
    color[1] = parseInt ((trim(hex)).substring (2, 4), 16);
    color[2] = parseInt ((trim(hex)).substring (4, 6), 16);
    return color;
}

function generateColor(colorStart,colorEnd,colorCount) {

	// The beginning of your gradient
	var start = convertToRGB (colorStart);

	// The end of your gradient
	var end   = convertToRGB (colorEnd);

	// The number of colors to compute
	var len = colorCount;

	//Alpha blending amount
	var alpha = 0.0;

	var saida = [];

	for (i = 0; i < len; i++) {
		var c = [];
		alpha += (1.0/len);

		c[0] = start[0] * alpha + (1 - alpha) * end[0];
		c[1] = start[1] * alpha + (1 - alpha) * end[1];
		c[2] = start[2] * alpha + (1 - alpha) * end[2];

		saida.push(convertToHex (c));

	}

	return saida;
}
</script>
<script>
/*
This module is done in plain HTML/Javascript because react-leaflet-choropleth
does not seem to be well-supported enough to bother with.
*/
$(document).ready(function() {
    console.log(workbench);

    // URL regex to parse for wfModuleId
    var urlPattern = /^(https?\:\/\/.*\/api\/wfmodules\/)([0-9]+).*/;

    var urlMatch = urlPattern.exec(window.location.href);
    const urlBase = urlMatch[1];
    const wfModuleId = urlMatch[2]
    if(!urlMatch) {
        $('#data-tag').html('Error parsing url.');
    }

    var geoJSONParam = {};
    var geoJSON = {};
    var geoJSONSource = 0;  // 0 correspond to Preset, 1 correspond to user upload
    try {
        geoJSONParam = JSON.parse(workbench.params['map-geojson']);
        geoJSON = geoJSONParam.geojson;
        geoJSONSource = workbench.params['geo-type'];
    } catch(e) {
        $(document.body).html('<p>Please specify a map geometry</p>');
        return;
    }

    var tokenParam = {};
    var token = '';
    try {
        tokenParam = JSON.parse(workbench.params['map-token']);
        token = tokenParam.tokenVal;
    } catch(e) {
        $(document.body).html('<p>Token is not provided</p>');
        return;
    }

    var keyColumn = workbench.params['key-column'];
    if(keyColumn == '') {
        $(document.body).html('<p>Please specify a column for location.</p>');
        return;
    }

    // Expand the geoJSON data to include our input data
    // We first transform the input data into a dictionary with the location as keys
    var dataDict = {};
    workbench.input.rows.forEach(function(row) {
        let location = row[keyColumn];
        dataDict[location] = {};
        for(let key in row) {
            if(key != keyColumn) {
                dataDict[location][key] = row[key];
            }
        }
    });
    console.log(dataDict);
    // We then combine the data into the "properties" field of the geoJSON data
    //console.log(geoJSON);
    // Add a prefix here to prevent conflict with geoJSON's original properties
    const colPrefix = 'wb-';
    for(let i = 0; i < geoJSON.features.length; i += 1) {
        if(dataDict[geoJSON.features[i].properties.name]) {
            for(let key in dataDict[geoJSON.features[i].properties.name]) {
                geoJSON.features[i].properties[colPrefix + key] = dataDict[geoJSON.features[i].properties.name][key];
            }
        }
    }
    console.log(geoJSON);

    // We run another pass over the input data to get the extremas of each value on the map
    // as well as whether the column is numeric values
    var dataExtremas = {};  // Dictionary of col -> [minVal, maxVal]
    var isNumeric = {};     // Dictionary of col -> bool
    workbench.input.rows.forEach(function(row) {
        for(let key in row) {
            if(key != keyColumn) {
                // Updates the extremas
                if(key in dataExtremas) {
                    if(row[key] > dataExtremas[key][1]) {
                        dataExtremas[key][1] = row[key]
                    } else if(row[key] < dataExtremas[key][0]) {
                        dataExtremas[key][0] = row[key]
                    }
                } else {
                    dataExtremas[key] = [row[key], row[key]];
                }
                // Updates isNumeric
                if(key in isNumeric) {
                    isNumeric[key] = ((!isNaN(row[key])) && isNumeric[key]);
                } else {
                    isNumeric[key] = (!isNaN(row[key]));
                }
            }
        }
    });

    console.log(dataExtremas);
    console.log(isNumeric);

    var numLevels = 10;

    var map = L.map('map-div').setView([37.8, -96], 4);
    L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=' + token, {
        id: 'mapbox.light',
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>'
    }).addTo(map);

    var colorLvls = generateColor('#800026', '#FFEDA0', numLevels);
    console.log(colorLvls);

    function getColor(val, extremas, numLvls) {
        if(val == undefined) {
            return '#000000';
        }
        let step = (extremas[1] - extremas[0]) / numLvls;
        let lvl = Math.floor((val - 1 - extremas[0]) / step);
        lvl = (lvl < 0) ? 0 : lvl;
        return (
            '#' + colorLvls[lvl]
        );
    }

    // Create a layer style for each column except for the location column
    var styles = {};
    workbench.input.columns.forEach(function(col) {
        if(col != keyColumn) {
            styles[col] = function(feature) {
                return {
                    fillColor: getColor(feature.properties[colPrefix + col], dataExtremas[col], numLevels),
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                }
            }
        }
    });

    // Define a variable to hold the active layer for style resetting
    var activeLayer = undefined;
    var activeLayerName = '';

    // Info overlay on hover
    var info = L.control();
    info.onAdd = function(map) {
        this._div = L.DomUtil.create('div', 'info');
        this.update();
        return this._div;
    };
    info.update = function(props) {
        if(!props) {
            this._div.innerHTML = '<h4>Hover over an area to see data</h4>';
        } else {
            this._div.innerHTML = (
                '<h4>' + props.name + '</h4>' +
                '<b>' + activeLayerName + '</b>&nbsp;<span>' + (props[colPrefix + activeLayerName] ? props[colPrefix + activeLayerName] : 'N/A') + '</span>'
            );
        }
    }
    info.addTo(map);

    // Create legend control on the map
    var legend = L.control({position: 'bottomright'});
    legend.onAdd = function(map) {
        this._div = L.DomUtil.create('div', 'info legend');
        this.update();
        return this._div;
    };
    legend.update = function(props) {
        this._div.innerHTML = '';
        if(!activeLayerName) {
            return;
        }
        let step = (dataExtremas[activeLayerName][1] - dataExtremas[activeLayerName][0]) / numLevels;
        for(let i = 0; i < numLevels; i ++) {
            this._div.innerHTML += (
                '<i style="background:#' + colorLvls[i] + '"></i>'
                + (dataExtremas[activeLayerName][0] + step * i).toString() + '-' + (dataExtremas[activeLayerName][0] + step * (i + 1)).toString() + '<br/>'
            );
        }
    };
    legend.addTo(map);

    // Define layer interactions
    function highlightFeature(e) {
        var layer = e.target;
        layer.setStyle({
            weight: 5,
            color: '#666',
            dashArray: '',
            fillOpacity: 0.7
        });
        if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
            layer.bringToFront();
        }
        info.update(layer.feature.properties);
    }

    function resetHighlight(e) {
        activeLayer.resetStyle(e.target);
        info.update();
    }

    function onEachFeature(feature, layer) {
        layer.on({
            mouseover: highlightFeature,
            mouseout: resetHighlight
        });
    }

    var layers = {};
    for(var col in styles) {
        layers[col] = L.geoJson(geoJSON, {style: styles[col], onEachFeature: onEachFeature});
    }

    // Create layer-switching control on the map
    var layerSwitcher = L.control({position: 'bottomleft'});
    layerSwitcher.onAdd = function(map) {
        this._div = L.DomUtil.create('div', 'info');
        let checkNext = true;
        for(var col in layers) {
            this._div.innerHTML += (
                '<div><input type="radio" value="' + col + '" name="layer-switch"' + (checkNext ? ' checked ' : '' ) + '/><label>' + col + '</label></div>'
            );
            if(checkNext) {
                activeLayer = layers[col];
                activeLayerName = col;
                activeLayer.addTo(map);
                legend.update();
                checkNext = false;
            }
        }
        $(this._div).find('input[type="radio"][name="layer-switch"]').change(function() {
            let checkedVal = $('input[type="radio"][name="layer-switch"]:checked').val();
            for(var col in layers) {
                layers[col].remove();
            }
            activeLayer = layers[checkedVal];
            activeLayerName = checkedVal;
            activeLayer.addTo(map);
            legend.update();
        });
        return this._div;
    }
    layerSwitcher.addTo(map);
});
</script>
</html>
